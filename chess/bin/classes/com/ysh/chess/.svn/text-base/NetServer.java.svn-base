package com.ysh.chess;


import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.util.Log;
import android.widget.Toast;




public class NetServer {
	private static final String LOGTAG = "XLMiniGameTest";
	private static final int mGameID = 2;
	private static final int mGameClassID = 1;
	
	//XLgame message
	static int MSG_REGISTER_GAME_CLIENT = 1;
	static final int MSG_REGISTER_GAME_HALL = 2;
	static final int MSG_UNREGISTER_GAME_CLIENT = 3;
	static final int MSG_UNREGISTER_GAME_HALL = 4;
	static final int MSG_CMD_GAME_TO_HALLS = 5;
	static final int MSG_CMD_HALLS_TO_GAME = 6;
	static final int MSG_CMD_HALLS_TO_HALL = 7;
	static final int MSG_CMD_HALL_TO_HALLS = 8;
	
	//USER_STATUS_CHANGE_ACTION
	static final int ENTER_TABLE_PLAY=1;//正常坐下
	static final int ENTER_TABLE_LOOKON=2;// 坐下旁观
	static final int USER_READY=3;// 点了“开始”
	static final int GAME_START=4;// 游戏开始
	static final int EXIT_TABLE=5;// 退出游戏（游戏桌）
	static final int EXIT_ROOM=6; // 退出房间
	static final int USER_DROPOUT=7;// 掉线
	static final int USER_DROP_RESUME=8;// 掉线恢复
	static final int GAME_END=9;// 游戏一局结束
	static final int USER_DROP_TIMEOUT=10;// 掉线超时
	
	static final int  CONN_ID_GETDIR_QUERY_ROOM_RESP = -202;
	
	
	
	static int mRoomID = -1;
	static int mZoneID = -1;
	static int mTableID = -1;
	static int mSeatID = -1;
	
	private short nCmdID[];
    
	private chess chessMain;
	private chessBoard cb;
	

	/** Messenger for communicating with service. */
	public static Messenger mService = null;
	/** Flag indicating whether we have called bind on the service. */
	boolean mIsBound;
	
	/**
	 * Handler of incoming messages from service.
	 */
	class IncomingHandler extends Handler {
	    @Override
	    public void handleMessage(Message msg) {
	    	Log.d(LOGTAG, "handleMessage: msg=" + msg.what);
	        switch (msg.what) {
	            case MSG_CMD_HALLS_TO_GAME:
	            	Bundle buData = msg.getData();
	                OnCmdHallService(buData);
	                break;
	                
	            default:
	                super.handleMessage(msg);
	        }
	    }
	}

	/**
	 * Target we publish for clients to send messages to IncomingHandler.
	 */
	final Messenger mMessenger = new Messenger(new IncomingHandler());
	  
	/**
	 * Class for interacting with the main interface of the service.
	 */
	private ServiceConnection mConnection = new ServiceConnection() {
	    public void onServiceConnected(ComponentName className, IBinder service) {
	        mService = new Messenger(service);
	        
	        Log.i(LOGTAG, "XLGameService connected");

	        try {
	        	// register hall client
	            Message msg = Message.obtain(null,
	            		MSG_REGISTER_GAME_CLIENT);  
	            msg.replyTo = mMessenger;
	            msg.arg1 = mGameClassID;
	            msg.arg2 = mGameID;
	            mService.send(msg);
	            
	            Bundle data = new Bundle();
	        	data.putInt("CmdID", 0);
	        	sendCmdToHall(data);
	        		        	
	        } catch (RemoteException e) {
	            // In this case the service has crashed before we could even
	            // do anything with it; we can count on soon being
	            // disconnected (and then reconnected if it can be restarted)
	            // so there is no need to do anything here.
	        	Log.e(LOGTAG, "send msg MSG_REGISTER_GAME_CLIENT failed!");
	        }
	        
	    }

	    public void onServiceDisconnected(ComponentName className) {
	        // This is called when the connection with the service has been
	        // unexpectedly disconnected -- that is, its process crashed.
	        mService = null;
	        Log.e(LOGTAG, "XLGameService crashed!");
	    }
	};
	public NetServer()
	{
		nCmdID = new short[]{-1,-1,-1,-1,-1,-1,-1};
	}
	public NetServer(chess chessMain,chessBoard cb){
		this.chessMain=chessMain;
		this.cb=cb;
	}
    

	void doBindService() {
	    // Establish a connection with the service.  We use an explicit
	    // class name because there is no reason to be able to let other
	    // applications replace our component.
		//内网用该语句，外网不用
       // cb.getChessMain().startActivity(new Intent("com.android.ysh.XLGame.action.UpdateUI"));
       
	    chessMain.bindService(new Intent("com.android.ysh.XLGame.action.XLGameService"), 
	    		mConnection, Context.BIND_AUTO_CREATE);
	    mIsBound = true;
	    
	    Log.i(LOGTAG, "doBindService finished");
	}

	void doUnbindService(){
	    if (mIsBound) {
	        // If we have received the service, and hence registered with
	        // it, then now is the time to unregister.
	        if (mService != null) {
	            try {
	                Message msg = Message.obtain(null,
	                        MSG_UNREGISTER_GAME_CLIENT);
	                msg.replyTo = mMessenger;
	                mService.send(msg);
	            } catch (RemoteException e) {
	                // There is nothing special we need to do if the service
	                // has crashed.
	            	Log.e(LOGTAG, "send msg MSG_UNREGISTER_GAME_CLIENT failed!");
	            }
	        }

	        // Detach our existing connection.
	        chessMain.unbindService(mConnection);
	        mIsBound = false;
	        
	        Log.i(LOGTAG, "doUnbindService finished");
	    }
	}

    
    private void sendCmdToHall(Bundle data) {
    	try {
        	// register hall client
            Message msg = Message.obtain(null,
                    MSG_CMD_GAME_TO_HALLS);            
            msg.arg1 = mGameClassID;
            msg.arg2 = mGameID;
            msg.setData(data);
            msg.replyTo = mMessenger;
            if(mService!=null)
            	mService.send(msg);
        } catch (RemoteException e) {
        	Log.e(LOGTAG, "send msg MSG_CMD_GAME_TO_HALLS failed!");
        }       	
    }
    
    public void submitGameAction(byte[] buf) {
    	Bundle data = new Bundle();
    	data.putInt("CmdID", 7);
    	data.putByteArray("Param1", buf);
    	sendCmdToHall(data);
    }
    
    private void OnCmdHallService(Bundle data){   
    	String cmdName = data.getString("_CmdName");
    	Log.i(LOGTAG, "OnCmdHallService - data=" + data + ", cmd=" + cmdName);
    	if(cmdName.equalsIgnoreCase("ConnectOK")){
    		queryRoom();
    		
    	}
    	if(cmdName.equalsIgnoreCase("OnQuerySuitedZoneResp")) {

    		int nGameID = data.getInt("GameID");
    		int nZoneID = data.getInt("ZoneID");
    		int nRoomID = data.getInt("RoomID");
    		
    		Log.i(LOGTAG, "[OnCmdHallService] OnQuerySuitedZoneResp - gameid=" + nGameID +
    				", zoneid=" + nZoneID + ", roomid=" + nRoomID);
    		
    		if(nGameID == mGameID) {
    			mZoneID = nZoneID;
    			mRoomID = nRoomID;
    		}
    		enterRoom();
    		
    	}  
    	else if(cmdName.equalsIgnoreCase("OnEnterRoomResp")) {
    		Log.i("enterRoomInfo",": "+data);
    		int nResult = data.getInt("Result");
    		if(nResult != 0) {
    			Log.e(LOGTAG, "OnEnterRoomResp - result=" + nResult);
    			if(nResult==114){
    				cb.releaseProgressMessage();
    				cb.ShowToast("当天逃跑次数达到上限，不允许再开始游戏，请24小时后重试");
    				cb.exit();
    			}
    			else{
    				cb.releaseProgressMessage();
    				cb.ShowToast("进入房间失败");
    				cb.exit();
    			}
    			return;
    		}
    		Log.i("OnEnterRoomResp",": GameID="+mGameID+"; ZoneID"+mZoneID+"; RoomID"+mRoomID);
    		enterGame();
    		
    	}
    	else if(cmdName.equalsIgnoreCase("TryEnterTableResp")) {
    		int nResult = data.getInt("Result");
    		Log.i("enterTableInfo",": "+data);
    		if(nResult != 0) {
    			Log.e(LOGTAG, "TryEnterTableResp - result=" + nResult);
		    	Toast t1 = Toast.makeText(chessMain, "进入游戏失败", Toast.LENGTH_LONG);
				t1.show();
				
				cb.exit();
	    		cb.setIsmOffline(true);
	    		if(cb.waitDlg!=null)//掉线关闭等待对话框
	    		{
	    			cb.waitDlg.dismiss();
	    			cb.waitDlg = null;
	    		}
	    		if(cb.timedlg != null)//掉线关闭时间确认对话框
	    		{
	    			cb.timedlg.dismiss();
	    			cb.timedlg = null;
	    		}
    			return;
    		}
    		
    		mTableID = (int)data.getShort("TableID");
    		mSeatID = (int)data.getShort("SeatID");
    		Bundle tablePlayers = data.getBundle("Param1");
    		Log.i("tablePlayers",": "+tablePlayers);
    		 //cb.setDisplayTableID(true);
    	    for(int i = 0; i < tablePlayers.size(); i++)
    	    {
    	    	String sSub = Integer.toString(i);
    	    	Bundle bSub = tablePlayers.getBundle(sSub);
    	    	if(mSeatID!=bSub.getShort("SeatID")){
    	    		cb.setdReady((int)bSub.getShort("UserStatus"));
    	    	}
    	    	long subID = bSub.getLong("UserID");
    	    
    	    	Log.i("bSub","("+i+"): "+bSub);
    	    	Log.i("TryEnterTableResp", ", " + subID + "=" + bSub);
    	    }
    	    
    	    
    		
    	    if(tablePlayers.size()==2){
    	    	  	    	
    	    	cb.setdSeat(true);
    	    	//cb.UserReadyTimerStart();
    	    }
    	     		
    	    Log.i("TryEnterTableResp",": TableID="+mTableID+"; SeatID="+mSeatID);
    	          	
        	cb.setEnterGame(true);
        	
        	cb.releaseProgressMessage();
        	cb.postInvalidate();  
    		gameReady();
    	
    		
    		//cb.showProgressMessage("等待对手准备...");
    	}
    	else if(cmdName.equalsIgnoreCase("NotifyUserInfoChanged")) {
    		
    	}
    	else if(cmdName.equalsIgnoreCase("KickoutReq")){//对方把你踢出房间
    	      cb.setEnterGame(false);
    	      cb.ShowToast("您被踢出房间");
    	      enterGame();
    	      
    	}
    	else if(cmdName.equalsIgnoreCase("NotifyUserStatusReq")){ //用户状态通知

    		int nTableID=data.getInt("TableID");
    		int nSeatID=data.getInt("SeatID");
    		long UserID=data.getLong("UserID");
    		int ChangeType=data.getShort("ChangeType");
    		Log.i("NotifyUserStatusReq", ": NotifyUserStatusReq - data="+data+"; TableID="+nTableID+"; SeatID="
    				                      +nSeatID+"; UserID="+UserID+"; ChangeType="+ChangeType);

			switch(ChangeType){
			case ENTER_TABLE_PLAY:
					cb.setdSeat(true);
				
					cb.setdReady(1);
					cb.UserReadyTimerStart();
					cb.postInvalidate();
				
				break;
    		case USER_READY: 
    			//如果没有准备好，则开始倒计时
    			cb.setdReady(2);
                cb.UserReadyTimerStop();
                cb.postInvalidate();
    			if(GAMESTATE.getGAMESTATEFromIndex(cb.getChessLogic().GetGameStatus()) != GAMESTATE.GAME_WAITING)

    				cb.SetReadyTimer(true);

    		    break;	

    		case GAME_END: 
    			 OnEndGameNotify(nTableID);
    			break;

        	case EXIT_TABLE:       		
        			cb.setdSeat(false);
        	        cb.setdReady(1);
        			cb.postInvalidate();
        		
        			if(cb.timedlg!=null){
        			   cb.timedlg.dismiss();
        			}
        			cb.releaseProgressMessage();
        	
        			break;
        	case USER_DROPOUT:
        			Message offlineMsg=new Message();
        			offlineMsg.what=7;
        			cb.getHandler().sendMessage(offlineMsg);
        			cb.setIsdOffline(true);
        			break;
        	case USER_DROP_RESUME:
        			offlineMsg=new Message();
        			offlineMsg.what=8;
        			cb.getHandler().sendMessage(offlineMsg);
        			cb.setIsdOffline(false);
        		
        			break;
        			
        	case USER_DROP_TIMEOUT:
        			break;
        		}		
    		
    	}
    	else if(cmdName.equalsIgnoreCase("SessionNetError")){  //网络异常
    		int result=data.getInt("result");
    		Log.i("NetError",": result="+result);
    		Message offlineMsg=new Message();
    		offlineMsg.what=6;
    		cb.getHandler().sendMessage(offlineMsg);
    		cb.setIsmOffline(true);
    		if(cb.waitDlg!=null)//掉线关闭等待对话框
    		{
    			cb.waitDlg.dismiss();
    			cb.waitDlg = null;
    		}
    		if(cb.timedlg != null)//掉线关闭时间确认对话框
    		{
    			cb.timedlg.dismiss();
    			cb.timedlg = null;
    		}
    	}
    	else if(cmdName.equalsIgnoreCase("NetworkError")){ 
    		int nConnID=data.getInt("Param1");
    		if(nConnID == CONN_ID_GETDIR_QUERY_ROOM_RESP) {
		    	Toast t1 = Toast.makeText(chessMain, "查询房间失败", Toast.LENGTH_LONG);
				t1.show();
				
				cb.exit();
	    		cb.setIsmOffline(true);
	    		if(cb.waitDlg!=null)//掉线关闭等待对话框
	    		{
	    			cb.waitDlg.dismiss();
	    			cb.waitDlg = null;
	    		}
	    		if(cb.timedlg != null)//掉线关闭时间确认对话框
	    		{
	    			cb.timedlg.dismiss();
	    			cb.timedlg = null;
	    		}
    		}
    	}
    	else if(cmdName.equalsIgnoreCase("GameActionNotify")) {    //大厅命令通知		
    		int nGameID = data.getInt("GameID");
    		int nZoneID = data.getInt("ZoneID");
    		int nRoomID = data.getInt("RoomID");
    		byte[] actionData = data.getByteArray("Param1");
    		long nSubmitUserID = data.getLong("UserID");
    		Log.i("GameActionNotify",": GameID="+nGameID+"; ZoneID"+nZoneID+"; RoomID"+nRoomID+"; UserID"+nSubmitUserID
    				                    +"; Action="+actionData[0]);
 
    		OnGameActionNotify(nSubmitUserID,actionData);
    		
    		
    		// TODO
    		// 在这里处理象棋的命令-在actionData里
    	}
    	else if(cmdName.equalsIgnoreCase("NeedReplay")) {    //重连成功通知		
    		 int net_type = chessMain.checkNetworkType();
    		 if( net_type == 65538 )
		    {
		    	Toast t1 = Toast.makeText(chessMain, "暂不支持联通WAP网络，请尝试其它连接", Toast.LENGTH_LONG);
				t1.show();
				
				cb.exit();
	    		cb.setIsmOffline(true);
	    		if(cb.waitDlg!=null)//掉线关闭等待对话框
	    		{
	    			cb.waitDlg.dismiss();
	    			cb.waitDlg = null;
	    		}
	    		if(cb.timedlg != null)//掉线关闭时间确认对话框
	    		{
	    			cb.timedlg.dismiss();
	    			cb.timedlg = null;
	    		}
	    		
		    }
		    else if( net_type == 65537 )
		    {
		    	Toast t1 = Toast.makeText(chessMain, "暂不支持移动WAP网络，请尝试其它连接", Toast.LENGTH_LONG);
				t1.show();
				cb.exit();
				cb.setIsmOffline(true);
	    		if(cb.waitDlg!=null)//掉线关闭等待对话框
	    		{
	    			cb.waitDlg.dismiss();
	    			cb.waitDlg = null;
	    		}
	    		if(cb.timedlg != null)//掉线关闭时间确认对话框
	    		{
	    			cb.timedlg.dismiss();
	    			cb.timedlg = null;
	    		}
		    }
		    else{
		    	sendReplay();
		    }
    	}
    }
    
    public void queryRoom(){
    	cb.showProgressMessage("正在查询房间...");
    	Bundle data=new Bundle();
    	data.putInt("CmdID", 1);
  	    sendCmdToHall(data);
    }
    
    public void enterRoom(){
    	cb.showProgressMessage("正在进入房间...");
    
    	if(mRoomID > 0 && mZoneID > 0) {
    		Bundle data=new Bundle();
          	data.putInt("CmdID", 2);
          	data.putInt("GameID", mGameID);
          	data.putInt("ZoneID", mZoneID);
          	data.putInt("RoomID", mRoomID);
          	sendCmdToHall(data);		        		
      	    }
    }
    
    public void enterGame(){
    	cb.showProgressMessage("正在进入游戏...");
    	Bundle data=new Bundle();
    	data.putInt("CmdID", 6);
      	sendCmdToHall(data);
    }
    public void gameReady(){
       
    	cb.getChessLogic().Call("INIT", 0, null);
    	cb.getChessLogic().Call("GETREADY",0,null);    
    	Bundle data=new Bundle();
    	data.putInt("CmdID", 3);
    	data.putInt("TableID", mTableID);
    	data.putInt("SeatID", mSeatID);
    	sendCmdToHall(data);
    	cb.setmReady(2);
    	cb.UserReadyTimerStart();

    }
    public void exitGame(){
    	Bundle data = new Bundle();
    	data.putInt("CmdID", 4);
    	data.putInt("TableID", mTableID);
    	sendCmdToHall(data);
    }
    
    public void exitRoom(){
    	Bundle data = new Bundle();
    	data.putInt("CmdID", 5);
    	sendCmdToHall(data);
    }
    
    public void sendReplay(){
    	Bundle data=new Bundle();
    	data.putInt("CmdID", 8);
    	sendCmdToHall(data);
    }
    
    public short[] getnCmdID(){
    	nCmdID[0]=(short)mGameID;
    	nCmdID[1]=(short)mZoneID;
    	nCmdID[2]=(short)mRoomID;
    	nCmdID[3]=(short)mTableID;
    	nCmdID[4]=(short)mSeatID;
    	return nCmdID;
    } 

    public native void OnGameActionNotify(long userID,byte[] a);
    public native void OnEndGameNotify(int nTableID);
    //public native void OnQuitGameNotify(long nUserID,int playerStatus);
}

