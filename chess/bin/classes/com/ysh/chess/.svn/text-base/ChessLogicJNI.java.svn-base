package com.ysh.chess;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.widget.Toast;

import android.os.Message;
import android.view.View;
public class ChessLogicJNI {
	//"STARTGAMEHAL" 初始化棋盘
	//"USERCLICK" 用户触发，得传入参数
	//"AIMOVE"	触发人工智能走棋
	//
	
    
	private  final int NOTIFY_NOTYPE=0,
	NOTIFY_CHOSED=1,
	NOTIFY_UNCHOSED=2,
	NOTIFY_WARNING=3,
    NOTIFY_VIOLATIONMOVES=4,
	NOTIFY_MOVEAPIECE=5,
  	NOTIFY_GAMEOVER=6,
	NOTIFY_PRACTICEHANDLERESULT=7,
	NOTIFY_NOCHOSED=8,
	NOTIFY_CANNOTMOVE=9,
	NOTIFY_SETTIME=10,
	NOTIFY_CONFIRMTIME=11,
	NOTIFY_GAMESTARTED=12,
	NOTIFY_USERQUITGAME=13,
	NOTIFY_RETRACTMOVES=14,
	NOTIFY_CantSendRetractMoveThisTime=15,
	NOTIFY_CantRetractToolMuchOnceTime=16,
	NOTIFY_CantRetractForJustUse=17,
	NOTIFY_CantRetractForMoreTimes=18,
	NOTIFY_RequestRetractMoveInvalid=19,
	NOTIFY_RequestRetractMoveRefused=20,
	NOTIFY_RequestRetractMove=21,
	NOTIFY_RequestDraw=22;
	
	
	public native int[][] GetChessMap();
	

	public native int Call(String method,int param1,int[] param2);
   
	public native boolean GetIsGameStarted();
	public native void SetPracticeGameOver();
	
	public native boolean GetFlagSide();
	public native boolean GetIsMyTurn();
	public native int GetGameStatus();
	public native int GetStepCount();

	public native void OnSvrRespSetGameOver();
	
	public native int GetPieceIndex(int index,int column);
	
	public native void InitVM(chess b);
	
	
	
	int time_set_flag;
	public void Fire_Notify(int[] array)
	{
		chessMan man;
		switch(array[0])
		{
		case NOTIFY_NOTYPE://NOTIFY_NOTYPE
			
			break;
		case NOTIFY_CHOSED://NOTIFY_CHOSED
			
			cb.timerStop();
			cb.setOldFocusPos(-1);
			cb.setNewFocusPos(-1);
			cb.setChosedMan(array[2]);
		    man=cb.getChessMan(array[2]);
	        man.setChosedX();//将x坐标值备份（在显示选中动画中需要）
	        
	        cb.getChessMain().playSound(3);
			cb.timerStart();
		    
			break;
		case NOTIFY_UNCHOSED://NOTIFY_UNCHOSED				   
		    cb.timerStop();
		    cb.setChosedMan(-1);
			break;
		case NOTIFY_WARNING://NOTIFY_WARNING
			
			break;
		case NOTIFY_VIOLATIONMOVES://NOTIFY_VIOLATIONMOVES
			if(array[2]==1){
				//Error Message:不允许对将
				cb.ShowToast("不允许对将");
			}
			else if(array[2]==3){
				//Error Message:不允许长将
				cb.ShowToast("不允许长将");
			}
			else if(array[2]==4){
				//Error Message:不允许长捉
				cb.ShowToast("不允许长捉");
			}
			break;
		case NOTIFY_MOVEAPIECE://NOTIFY_MOVEAPIECE
			if(cb.gameType==GAMETYPE.ONLINEGAME){
	        	 cb.resetTimeLimit();
	        	 if(!GetIsMyTurn())
	        	    cb.getChessMain().playSound(6);
	        }
			if(cb.gameType==GAMETYPE.PRACTICEGAME){
				if(cb.getAIMove()){
					cb.setAIMove(false);
					cb.getChessMain().playSound(6);				
				}				
				else
				    cb.setAIMove(true);
			}
			if((cb.getSideFlag()==0)||cb.gameType==GAMETYPE.PRACTICEGAME){

				cb.setOldFocusPos(89-array[3]);
				cb.setNewFocusPos(89-array[6]);
				
			}
			else{
				
					cb.setOldFocusPos(array[3]);
					cb.setNewFocusPos(array[6]);
				}
			
			cb.timerStop();
			man=cb.getChessMan(array[5]);
			int y=array[6]/9;
			int x=array[6]-9*y;
		
            man.setX(x);
            man.setY(y);
            
    		if(array.length<11)//吃子
			{
				man=cb.getChessMan(array[7]);
				man.setX(-1);
				cb.getChessMain().playSound(2);
			}
    		
			if(array[2]==2)//将军
			{
                cb.setIsCheck(true);
				cb.getChessMain().playSound(4);
			}
			else if(array[2] == 1) //吃子
			{
				man=cb.getChessMan(array[7]);
				man.setX(-1);
				cb.getChessMain().playSound(2);
			}
			else //走子
		        cb.getChessMain().playSound(1);
			       
			cb.postInvalidate();
			break;
		case NOTIFY_GAMEOVER://NOTIFY_GAMEOVER
			cb.timerStop();
			switch(array[2]){
			case 0://双方协商时间失败


				if(GAMESTATE.getGAMESTATEFromIndex(cb.getChessLogic().GetGameStatus()) == GAMESTATE.GAME_SETTING)//防止离开之后仍然弹出信息
				{

					cb.setdReady(1);
					cb.setmReady(1);
					cb.releaseProgressMessage();
					cb.postInvalidate();
					cb.ShowToast("协商时间失败");
                    cb.getnServer().gameReady();
              
                    //cb.UserReadyTimerStart();
                    cb.postInvalidate();
				}
				return;//不结束，只放下手
			case 1://红方胜利
				
				cb.setWhoWin(cb.getSideFlag());
			    
				break;
			case 2://黑方胜利
				
			    cb.setWhoWin(1-cb.getSideFlag());
				
				break;
			case 3://很遗憾，本局您和对手战成平局
				cb.ShowToast("很遗憾，您和对手战成平局！");
				break;
			case 4://对方逃跑
				cb.setWhoWin(0);
				cb.ShowToast("对方逃跑！");
				break;
			case 5://恭喜您，对方认输了
				cb.setWhoWin(0);
				cb.ShowToast("对方认输！");
				break;
			case 6://红方超时
				cb.setWhoWin(1-cb.getSideFlag());
								
				 cb.ShowToast((cb.getSideFlag()==0)? "您已经超时！":"对方已经超时！");
				
				break;
			case 7://黑方超时
				cb.setWhoWin(cb.getSideFlag());
				cb.ShowToast((cb.getSideFlag()==1)? "您已经超时！":"对方已经超时！");
				break;
								
			}
			cb.setGameOver(true);
			cb.stepTimerStop();
			cb.UserReadyTimerStop();
			cb.postInvalidate();
			break;
		case NOTIFY_PRACTICEHANDLERESULT:
			if(cb.getAIMove())
				cb.setWhoWin(1);
			else
				cb.setWhoWin(0);
			cb.setGameOver(true);
			break;
		case NOTIFY_NOCHOSED:	//什么都没选
			//cb.setMoveFlag(false);
			break;
		case NOTIFY_CANNOTMOVE: //不能走报警

			break;
		case NOTIFY_SETTIME://NOTIFY_SETTIME

			if(array[1]==1)
			{
				//弹出窗口正在等待
				cb.showProgressMessage("等待对手设置时间");
			}
			else
			{
				//弹出设置时间的窗口

				cb.timedlg = new TimeSettingDialog(cb,"REPLYSETTIME",array[1],true,DLGTYPE.TIME_SET);
				cb.timedlg.setDisplay();
			}


			break;
		case NOTIFY_CONFIRMTIME://NOTIFY_CONFIRMTIME
			if(array[1] == 1)
			{
					
			}
			else
			{
				int rt = array[3];
				int sat = array[4];
				int stl = array[5];
				cb.releaseProgressMessage();
				cb.timedlg = new TimeSettingDialog(cb,"REPLYCONFIRMTIME",array[1],false,DLGTYPE.TIME_CONFIRM);
				cb.timedlg.setTimeContent(rt,sat,stl);
				cb.timedlg.setDisplay();
			}
			break;
		case NOTIFY_GAMESTARTED://NOTIFY_GAMESTARTED
			if(cb.waitDlg != null)
			{
				cb.waitDlg.dismiss();
				cb.waitDlg = null;	
			}
			cb.setSideFlag(array[1]);
            cb.setdReady(-1); //双方准备状态复位
            cb.setmReady(-1);
            
            cb.getChessMain().playSound(5);
            if(cb.gameType==GAMETYPE.ONLINEGAME)
                cb.stepTimerStart();
            else
			  cb.postInvalidate();
			break;
		case NOTIFY_USERQUITGAME://NOTIFY_USERQUITGAME
			if(array[2]==1){//值为1为对方退出游戏，0为己方退出游戏
				   
			}
		case NOTIFY_RETRACTMOVES://NOTIFY_RETRACTMOVES  悔棋后完成通知

			int fromY=array[3]/9;
			int fromX=array[3]-9*fromY;
			int toY=array[4]/9;
			int toX=array[4]-9*toY;
			if((cb.getSideFlag()==0)||cb.gameType==GAMETYPE.PRACTICEGAME){

				cb.setOldFocusPos(89-array[3]);
				cb.setNewFocusPos(89-array[4]);
				
			}
			else{
				
					cb.setOldFocusPos(array[3]);
					cb.setNewFocusPos(array[4]);
			}
			for(int i=5;i<array.length-1;i+=2){
				if(array[i]>=0&&array[i]<32){
					man=cb.getChessMan(array[i]);
					
				    y=array[i+1]/9;
			        x=array[i+1]-9*y;
					man.setX(x);
					man.setY(y);
					
				}
			}

			if(cb.waitDlg != null)
			{
				cb.waitDlg.dismiss();	
				cb.waitDlg = null;	
			}
			cb.setPressRetract(false);
			cb.postInvalidate();
			break;
		case NOTIFY_CantSendRetractMoveThisTime:
		case NOTIFY_CantRetractToolMuchOnceTime:
		case NOTIFY_CantRetractForJustUse:
		case NOTIFY_CantRetractForMoreTimes:
		case NOTIFY_RequestRetractMoveInvalid:
		case NOTIFY_RequestRetractMoveRefused:
			if(cb.waitDlg != null)
			{
				cb.waitDlg.dismiss();	
				cb.waitDlg = null;
			}
			
			new AlertDialog.Builder(cb.getChessMain())
			.setMessage(R.string.refuseRetract)
			.setPositiveButton(R.string.confirm,new DialogInterface.OnClickListener() {					
				@Override
				public void onClick(DialogInterface dialog, int which) {
					// TODO Auto-generated method stub
				}
			})
			.show();
			
			cb.setPressRetract(false);
			break;
		case NOTIFY_RequestRetractMove://NOTIFY_RequestRetractMove 对方请求悔棋
			cb.timerStop();
			new AlertDialog.Builder(cb.getChessMain())
			.setMessage(R.string.requestRetract)
			.setPositiveButton(R.string.confirm,new DialogInterface.OnClickListener() {					
				@Override
				public void onClick(DialogInterface dialog, int which) {
					// TODO Auto-generated method stub	
					Call("REPLYRETRACTMOVE",1,null);
				    					
				}
			})
			.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					Call("REPLYRETRACTMOVE",0,null);
					// TODO Auto-generated method stub
					
				}
			})
			.show();
			break;
		case NOTIFY_RequestDraw:
			cb.timerStop();
			new AlertDialog.Builder(cb.getChessMain())
			.setMessage(R.string.requestDraw)
			.setPositiveButton(R.string.confirm, new DialogInterface.OnClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					// TODO Auto-generated method stub
					Call("REPLYDRAW",1,null);
				}
			})
			.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					// TODO Auto-generated method stub
					Call("REPLYDRAW",0,null);
				}
			})
			.show();
			
		}
		return;
	}
		
	public static chessBoard cb;
	
}
